{"version":3,"sources":["main.js","dbhelper.js"],"names":["restaurants","neighborhoods","cuisines","map","markers","document","addEventListener","event","updateRestaurants","fetchNeighborhoods","fetchCuisines","DBHelper","error","console","self","fillNeighborhoodsHTML","select","getElementById","forEach","neighborhood","option","createElement","innerHTML","value","append","fillCuisinesHTML","cuisine","window","initMap","style","display","google","maps","Map","zoom","center","lat","lng","scrollwheel","cSelect","nSelect","cIndex","selectedIndex","nIndex","fetchRestaurantByCuisineAndNeighborhood","resetRestaurants","fillRestaurantsHTML","m","setMap","div","restaurant","createRestaurantHTML","addMarkersToMap","imageSrc","imageUrlForRestaurant","image","className","src","alt","imageAltText","div2","name","favButton","type","classList","add","onclick","isFav","is_favorite","updateFavStatus","id","changeFavButton","address","more","href","urlForRestaurant","role","createAttribute","setAttributeNode","tabi","label","element","setAttribute","remove","marker","mapMarkerForRestaurant","addListener","location","url","push","hamIconClick","icon","parentNode","removeChild","dbName","storeName","reviewsStoreName","API_URL_BASE","API_URL","dbPromise","navigator","serviceWorker","idb","open","db","createObjectStore","keyPath","autoIncrement","createIndex","Promise","resolve","[object Object]","callback","then","transaction","objectStore","getAll","length","xhrForRestaurant","xhr","XMLHttpRequest","onload","status","restaurantsFromJson","JSON","parse","responseText","storeRestaurantsDB","send","store","put","fetchRestaurants","find","r","results","filter","cuisine_type","v","i","uniqueNeighborhoods","indexOf","uniqueCuisines","undefined","photograph","Marker","position","latlng","title","animation","Animation","DROP","fetch","method","get","onLine","response","json","data","Array","isArray","review","catch","index","storedREviews","onlineAddReview","offlineAddReview","localStorage","setItem","stringify","offline_review","getItem","addReviewToServer","removeItem","offlineItems","getElementsByClassName","headers","Headers","Content-Type","body","log"],"mappings":"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","file":"../app.min.js","sourcesContent":["\r\nlet restaurants,\r\n  neighborhoods,\r\n  cuisines\r\nvar map\r\nvar markers = []\r\n\r\n/**\r\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n  updateRestaurants();\r\n  fetchNeighborhoods();\r\n  fetchCuisines();\r\n});\r\n\r\n/**\r\n * Fetch all neighborhoods and set their HTML.\r\n */\r\nfetchNeighborhoods = () => {\r\n  DBHelper.fetchNeighborhoods((error, neighborhoods) => {\r\n    if (error) { // Got an error\r\n      console.error(error);\r\n    } else {\r\n      self.neighborhoods = neighborhoods;\r\n      fillNeighborhoodsHTML();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Set neighborhoods HTML.\r\n */\r\nfillNeighborhoodsHTML = (neighborhoods = self.neighborhoods) => {\r\n  const select = document.getElementById('neighborhoods-select');\r\n  neighborhoods.forEach(neighborhood => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = neighborhood;\r\n    option.value = neighborhood;\r\n    select.append(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch all cuisines and set their HTML.\r\n */\r\nfetchCuisines = () => {\r\n  DBHelper.fetchCuisines((error, cuisines) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      self.cuisines = cuisines;\r\n      fillCuisinesHTML();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Set cuisines HTML.\r\n */\r\nfillCuisinesHTML = (cuisines = self.cuisines) => {\r\n  const select = document.getElementById('cuisines-select');\r\n\r\n  cuisines.forEach(cuisine => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = cuisine;\r\n    option.value = cuisine;\r\n    select.append(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n */\r\nwindow.initMap = () => {\r\n  if(document.getElementById('map-container').style.display == 'none' || map) return;\r\n  let loc = {\r\n    lat: 40.722216,\r\n    lng: -73.987501\r\n  };\r\n  self.map = new google.maps.Map(document.getElementById('map'), {\r\n    zoom: 12,\r\n    center: loc,\r\n    scrollwheel: false\r\n  });\r\n}\r\n\r\n/**\r\n * Update page and map for current restaurants.\r\n */\r\nupdateRestaurants = () => {\r\n  const cSelect = document.getElementById('cuisines-select');\r\n  const nSelect = document.getElementById('neighborhoods-select');\r\n\r\n  const cIndex = cSelect.selectedIndex;\r\n  const nIndex = nSelect.selectedIndex;\r\n\r\n  const cuisine = cSelect[cIndex].value;\r\n  const neighborhood = nSelect[nIndex].value;\r\n\r\n  DBHelper.fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, (error, restaurants) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      resetRestaurants(restaurants);\r\n      fillRestaurantsHTML();\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Clear current restaurants, their HTML and remove their map markers.\r\n */\r\nresetRestaurants = (restaurants) => {\r\n  // Remove all restaurants\r\n  self.restaurants = [];\r\n  const ul = document.getElementById('restaurants-list');\r\n  ul.innerHTML = '';\r\n\r\n  // Remove all map markers\r\n  self.markers.forEach(m => m.setMap(null));\r\n  self.markers = [];\r\n  self.restaurants = restaurants;\r\n}\r\n\r\n/**\r\n * Create all restaurants HTML and add them to the webpage.\r\n */\r\nfillRestaurantsHTML = (restaurants = self.restaurants) => {\r\n  const div = document.getElementById('restaurants-list');\r\n  restaurants.forEach(restaurant => {\r\n    div.append(createRestaurantHTML(restaurant));\r\n  });\r\n  addMarkersToMap();\r\n}\r\n\r\n/**\r\n * Create restaurant HTML.\r\n */\r\ncreateRestaurantHTML = (restaurant) => {\r\n  const div = document.createElement('div');\r\n\r\n  var imageSrc = DBHelper.imageUrlForRestaurant(restaurant);\r\n  const image = document.createElement('img');\r\n  image.className = 'restaurant-img';\r\n  if(imageSrc)\r\n    image.src = imageSrc;\r\n  image.alt = DBHelper.imageAltText(restaurant);\r\n  div.append(image);\r\n\r\n  const div2 = document.createElement('div');\r\n  const name = document.createElement('h2');\r\n  name.innerHTML = restaurant.name;\r\n  div2.append(name);\r\n\r\n  const favButton = document.createElement('button');\r\n  favButton.type = 'button';\r\n  favButton.classList.add('favButton');\r\n  favButton.innerHTML = '❤';\r\n  favButton.onclick = () => {\r\n    let isFav = !restaurant.is_favorite;\r\n    DBHelper.updateFavStatus(restaurant.id, isFav);\r\n    restaurant.is_favorite = isFav;\r\n    changeFavButton(favButton, restaurant.is_favorite);\r\n  };  \r\n  changeFavButton(favButton, restaurant.is_favorite);\r\n  div2.append(favButton);\r\n\r\n  const neighborhood = document.createElement('p');\r\n  neighborhood.innerHTML = restaurant.neighborhood;\r\n  div2.append(neighborhood);\r\n\r\n  const address = document.createElement('p');\r\n  address.innerHTML = restaurant.address;\r\n  div2.append(address);\r\n\r\n  const more = document.createElement('a');\r\n  more.innerHTML = 'View Details';\r\n  more.href = DBHelper.urlForRestaurant(restaurant);\r\n  var role = document.createAttribute('role');\r\n  role.value = 'button';\r\n  more.setAttributeNode(role);  \r\n  var tabi = document.createAttribute('tabindex');\r\n  tabi.value = 0;\r\n  more.setAttributeNode(tabi);  \r\n  var label = document.createAttribute('aria-label');\r\n  label.value = 'detail for ' + restaurant.name + ' restaurant';\r\n  more.setAttributeNode(label); \r\n  div2.append(more)\r\n\r\n  div.append(div2);\r\n  return div\r\n}\r\n\r\n/**\r\n * Change attributes of favorite buttons when user clicks it\r\n */\r\nchangeFavButton = (element, isFav) => {\r\n  if(isFav) {\r\n    element.setAttribute('aria-label', 'Set as not favorite restaurant.')\r\n    element.classList.add('fav');\r\n    element.classList.remove('notFav');\r\n  } else {\r\n    element.setAttribute('aria-label', 'Set as favorite restaurant.')\r\n    element.classList.add('notFav');\r\n    element.classList.remove('fav');\r\n  }\r\n}\r\n\r\n/**\r\n * Add markers for current restaurants to the map.\r\n */\r\naddMarkersToMap = (restaurants = self.restaurants) => {\r\n  if(!self.map) return;\r\n  restaurants.forEach(restaurant => {\r\n    // Add marker to the map\r\n    const marker = DBHelper.mapMarkerForRestaurant(restaurant, self.map);\r\n    google.maps.event.addListener(marker, 'click', () => {\r\n      window.location.href = marker.url\r\n    });\r\n    self.markers.push(marker);\r\n  });\r\n}\r\n\r\nhamIconClick = () => {\r\n  var icon = document.getElementById('ham_icon');\r\n  icon.parentNode.removeChild(icon);\r\n  \r\n  var map = document.getElementById('map-container');\r\n  map.style.display = 'block';\r\n  if(!map) {\r\n    initMap();\r\n  }\r\n}","//name of the database name\r\nconst dbName = 'restaurants';\r\n//name of the store name with restaurants\r\nconst storeName = 'restaurants';\r\n//name of the store name with reviews\r\nconst reviewsStoreName = 'reviews';\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL_BASE() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with data\r\n    return `http://127.0.0.1:${port}/`;\r\n  }\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with restaurant data\r\n    return `http://127.0.0.1:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Promise for indexdb db.\r\n   */\r\n  static get dbPromise() {    \r\n    //if there is no service worker available, just return\r\n    if(!navigator.serviceWorker) return Promise.resolve();\r\n    //opening db\r\n    return idb.open(dbName, 1, (db) => {\r\n      db.createObjectStore(storeName, {keyPath:'id'});\r\n      var reviewsStore = db.createObjectStore(reviewsStoreName, {keyPath:'id', autoIncrement: true});\r\n      reviewsStore.createIndex('restaurant_id', 'restaurant_id');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    DBHelper.dbPromise.then(db => {\r\n      //there is no db, so first fetching of data\r\n      if(!db) {\r\n        //fetch data from server\r\n        DBHelper.xhrForRestaurant(callback);\r\n      } else {\r\n        //db exists, just get data from there\r\n        const tx = db.transaction(dbName);\r\n        const store = tx.objectStore(storeName);\r\n        store.getAll().then(restaurants => {\r\n          if(!restaurants || restaurants.length === 0) {\r\n            //no restaurants available?\r\n            DBHelper.xhrForRestaurant(callback);\r\n          } else {\r\n            //we have restaurants, yay, send them through\r\n            callback(null, restaurants)\r\n          }\r\n        });\r\n      }\r\n    });    \r\n  }\r\n\r\n  /**\r\n   * Fetch data throught xmlhttprequest\r\n   */\r\n  static xhrForRestaurant(callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.API_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const restaurantsFromJson = JSON.parse(xhr.responseText);\r\n        //save restaurants to db\r\n        DBHelper.storeRestaurantsDB(restaurantsFromJson);\r\n        callback(null, restaurantsFromJson);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }              \r\n    };\r\n    xhr.send();\r\n  }\r\n\r\n  /**\r\n   * Store all fetched restaurants in indexDB.\r\n   */\r\n  static storeRestaurantsDB(restaurants) {\r\n    DBHelper.dbPromise.then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction(dbName, \"readwrite\");\r\n      const store = tx.objectStore(storeName);\r\n      restaurants.forEach(restaurant => {\r\n        store.put(restaurant);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    if(!restaurant || restaurant.photograph === undefined) return null;\r\n    return (`/img/${restaurant.photograph}.webp`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n  static imageAltText(restaurant) {\r\n    return restaurant.name + ' restaurant in ' + restaurant.neighborhood + ' offers ' + restaurant.cuisine_type + ' cuisine type';\r\n  }\r\n\r\n  /**\r\n   * Update the favorite status of the restaurant. Based on id of restaurant and tru/false value of favorite.\r\n   */\r\n  static updateFavStatus(id, isFav) {\r\n    fetch(DBHelper.API_URL+'/'+id+'/'+'?is_favorite='+isFav,{method:'PUT'})\r\n    .then(() => {\r\n      DBHelper.dbPromise.then(db => {        \r\n        const tx = db.transaction(dbName, 'readwrite');\r\n        const store = tx.objectStore(storeName);\r\n        store.get(id).then(restaurant => {\r\n          restaurant.is_favorite = isFav;\r\n          store.put(restaurant);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews to the restaurant\r\n   */\r\n  static fetchReviewsRestaurantId(id) {\r\n    // let xhr = new XMLHttpRequest();\r\n    // xhr.open('GET', DBHelper.API_URL_BASE+'reviews/?restaurant_id='+id);\r\n    // xhr.onload = () => {\r\n    //   if (xhr.status === 200) { // Got a success response from server!\r\n    //     const reviews = JSON.parse(xhr.responseText);\r\n    //     return DBHelper.dbPromise.then(db => {\r\n    //       const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n    //       const store = tx.objectStore(reviewsStoreName);\r\n    //       if(Array.isArray(reviews)) {\r\n    //         reviews.forEach((review) => {\r\n    //           store.put(review);\r\n    //         });\r\n    //       } else {\r\n    //         store.put(reviews);\r\n    //       }\r\n    //     });\r\n    //     return Promise.resolve(reviews);\r\n    //   } else { // Oops!. Got an error from server.\r\n    //     const error = (`Request failed. Returned status of ${xhr.status}`);\r\n    //     return DBHelper.dbPromise.then(db => {        \r\n    //       const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n    //       const store = tx.objectStore(reviewsStoreName);\r\n    //       const indexId = store.index(dbName);\r\n    //       return indexId.getAll(id);\r\n    //     }).then((storedREviews) => {\r\n    //       return Promise.resolve(storedREviews);\r\n    //     })\r\n    //   }              \r\n    // };\r\n    // xhr.send();\r\n    if(navigator.onLine) {\r\n        return fetch(DBHelper.API_URL_BASE+'reviews/?restaurant_id='+id)\r\n      .then((response) => {\r\n        return response.json().then((data) => {\r\n          return DBHelper.dbPromise.then(db => {\r\n            const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n            const store = tx.objectStore(reviewsStoreName);\r\n            if(Array.isArray(data)) {\r\n              data.forEach((review) => {\r\n                store.put(review);\r\n              });\r\n            } else {\r\n              store.put(data);\r\n            }\r\n            return Promise.resolve(data);\r\n          });\r\n        });      \r\n      }).catch((error) => {\r\n        return DBHelper.dbPromise.then(db => {        \r\n          const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n          const store = tx.objectStore(reviewsStoreName);\r\n          const indexId = store.index('restaurant_id');\r\n          return indexId.getAll(id);\r\n        }).then((storedREviews) => {\r\n          return Promise.resolve(storedREviews);\r\n        })\r\n      });\r\n    } else {\r\n      return DBHelper.dbPromise.then(db => {        \r\n        const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n        const store = tx.objectStore(reviewsStoreName);\r\n        const indexId = store.index('restaurant_id');\r\n        return indexId.getAll(id);\r\n      }).then((storedREviews) => {\r\n        return Promise.resolve(storedREviews);\r\n      })\r\n    }    \r\n  }\r\n\r\n  /**\r\n   * Reporting review to server and db\r\n   */\r\n  static addReviewToServer(review) {\r\n    if(navigator.onLine) {\r\n      DBHelper.onlineAddReview(review);\r\n    } else {\r\n      DBHelper.offlineAddReview(review);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reporting review to idb\r\n   */\r\n  static addReviewToIDB(review) {\r\n    //put to indexdb\r\n    DBHelper.dbPromise.then(db => {\r\n      const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n      const store = tx.objectStore(reviewsStoreName);\r\n      store.put(review);      \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Processing review, when the user is offline\r\n   */\r\n  static offlineAddReview(review) {\r\n    const offline_review_key = 'offline_review';\r\n    localStorage.setItem(offline_review_key, JSON.stringify(review));\r\n    window.addEventListener('online', (event) => {\r\n      let offline_review = JSON.parse(localStorage.getItem(offline_review_key));\r\n      if(offline_review) {\r\n        DBHelper.addReviewToServer(offline_review);\r\n        localStorage.removeItem(offline_review_key);\r\n        var offlineItems = document.getElementById('reviews-list').getElementsByClassName('offline');\r\n        if(offlineItems) {\r\n          for (var i = 0; i < offlineItems.length; i++) {\r\n            offlineItems[i].classList.remove('offline');\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Processing review, when the user is offline\r\n   */\r\n  static onlineAddReview(review) {\r\n    fetch(DBHelper.API_URL_BASE + 'reviews', \r\n    {\r\n      method:'POST', \r\n      headers: new Headers({'Content-Type': 'application/json'}), \r\n      body: JSON.stringify(review)\r\n    }).then((response) => {\r\n      return response;\r\n    }).catch((error) => {\r\n      console.log('error in posting online review');\r\n      console.log(error);\r\n    });\r\n  }\r\n\r\n}"]}