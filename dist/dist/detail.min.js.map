{"version":3,"sources":["restaurant_info.js","dbhelper.js"],"names":["restaurant","map","id","window","initMap","fetchRestaurantFromURL","error","console","self","google","maps","Map","document","getElementById","zoom","center","latlng","scrollwheel","fillBreadcrumb","DBHelper","mapMarkerForRestaurant","addEventListener","event","callback","getParameterByName","fetchRestaurantById","fillRestaurantHTML","innerHTML","name","address","image","className","src","imageUrlForRestaurant","alt","imageAltText","cuisine_type","fillRestaurantReviews","operating_hours","fillRestaurantHoursHTML","fillReviewsHTML","operatingHours","hours","key","row","createElement","day","appendChild","time","reviews","container","title","noReviews","ul","forEach","review","createReviewHTML","li","date","rating","comments","breadcrumb","url","location","href","replace","results","RegExp","exec","decodeURIComponent","addReview","author","comment","i","rationRadio","checked","errors","returnErrors","value","errorH","errorHead","parentNode","removeChild","restaurant_id","log","addReviewToServer","addReviewToHtml","reset","noREviews","createdAt","Date","dbName","storeName","reviewsStoreName","API_URL_BASE","API_URL","dbPromise","navigator","serviceWorker","idb","open","db","createObjectStore","keyPath","Promise","resolve","[object Object]","then","transaction","objectStore","getAll","restaurants","length","xhrForRestaurant","xhr","XMLHttpRequest","onload","status","restaurantsFromJson","JSON","parse","responseText","storeRestaurantsDB","send","store","put","fetchRestaurants","find","r","cuisine","filter","neighborhood","neighborhoods","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","undefined","photograph","Marker","position","urlForRestaurant","animation","Animation","DROP","isFav","fetch","method","get","is_favorite","response","json","Array","isArray","catch","index","storedREviews","onLine","onlineAddReview","offlineAddReview","localStorage","setItem","stringify","offline_review","getItem","removeItem","headers","Headers","Content-Type","body"],"mappings":"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","file":"../detail.min.js","sourcesContent":["let restaurant;\r\nvar map;\r\nlet id;\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n */\r\nwindow.initMap = () => {\r\n  fetchRestaurantFromURL((error, restaurant) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      self.map = new google.maps.Map(document.getElementById('map'), {\r\n        zoom: 16,\r\n        center: restaurant.latlng,\r\n        scrollwheel: false\r\n      });\r\n      fillBreadcrumb();\r\n      DBHelper.mapMarkerForRestaurant(self.restaurant, self.map);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n  fetchRestaurantFromURL((error, restaurant) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      fillBreadcrumb();\r\n    }\r\n  });\r\n});\r\n\r\n/**\r\n * Get current restaurant from page URL.\r\n */\r\nfetchRestaurantFromURL = (callback) => {\r\n  if (self.restaurant) { // restaurant already fetched!\r\n    callback(null, self.restaurant)\r\n    return;\r\n  }\r\n  const id = getParameterByName('id');\r\n  if (!id) { // no id found in URL\r\n    error = 'No restaurant id in URL'\r\n    callback(error, null);\r\n  } else {\r\n    DBHelper.fetchRestaurantById(id, (error, restaurant) => {\r\n      self.restaurant = restaurant;\r\n      self.id = id;\r\n      if (!restaurant) {\r\n        console.error(error);\r\n        return;\r\n      }\r\n      fillRestaurantHTML();\r\n      callback(null, restaurant)\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Create restaurant HTML and add it to the webpage\r\n */\r\nfillRestaurantHTML = (restaurant = self.restaurant) => {\r\n  const name = document.getElementById('restaurant-name');\r\n  name.innerHTML = restaurant.name;\r\n\r\n  const address = document.getElementById('restaurant-address');\r\n  address.innerHTML = restaurant.address;\r\n\r\n  const image = document.getElementById('restaurant-img');\r\n  image.className = 'restaurant-img'\r\n  image.src = DBHelper.imageUrlForRestaurant(restaurant);\r\n  image.alt = DBHelper.imageAltText(restaurant);\r\n\r\n  const cuisine = document.getElementById('restaurant-cuisine');\r\n  cuisine.innerHTML = restaurant.cuisine_type;\r\n  //fill reviews\r\n  fillRestaurantReviews(restaurant.id);\r\n  // fill operating hours\r\n  if (restaurant.operating_hours) {\r\n    fillRestaurantHoursHTML();\r\n  }\r\n  // fill reviews\r\n  fillReviewsHTML();\r\n}\r\n\r\n/**\r\n * Create restaurant operating hours HTML table and add it to the webpage.\r\n */\r\nfillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {\r\n  const hours = document.getElementById('restaurant-hours');\r\n  for (let key in operatingHours) {\r\n    const row = document.createElement('tr');\r\n\r\n    const day = document.createElement('td');\r\n    day.innerHTML = key;\r\n    row.appendChild(day);\r\n\r\n    const time = document.createElement('td');\r\n    time.innerHTML = operatingHours[key];\r\n    row.appendChild(time);\r\n\r\n    hours.appendChild(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Create all reviews HTML and add them to the webpage.\r\n */\r\nfillReviewsHTML = (reviews = self.restaurant.reviews) => {\r\n  const container = document.getElementById('reviews-container');\r\n  const title = document.createElement('h3');\r\n  title.innerHTML = 'Reviews';\r\n  container.appendChild(title);\r\n\r\n  if (!reviews) {\r\n    const noReviews = document.createElement('p');\r\n    noReviews.innerHTML = 'No reviews yet!';\r\n    noReviews.id = 'noReviews';\r\n    container.appendChild(noReviews);\r\n    return;\r\n  }\r\n  const ul = document.getElementById('reviews-list');\r\n  reviews.forEach(review => {\r\n    ul.appendChild(createReviewHTML(review));\r\n  });\r\n  container.appendChild(ul);\r\n}\r\n\r\n/**\r\n * Create review HTML and add it to the webpage.\r\n */\r\ncreateReviewHTML = (review) => {\r\n  const li = document.createElement('li');\r\n  const name = document.createElement('p');\r\n  name.innerHTML = review.name;\r\n  li.appendChild(name);\r\n\r\n  const date = document.createElement('p');\r\n  date.innerHTML = review.date;\r\n  li.appendChild(date);\r\n\r\n  const rating = document.createElement('p');\r\n  rating.innerHTML = `Rating: ${review.rating}`;\r\n  li.appendChild(rating);\r\n\r\n  const comments = document.createElement('p');\r\n  comments.innerHTML = review.comments;\r\n  li.appendChild(comments);\r\n\r\n  return li;\r\n}\r\n\r\n/**\r\n * Add restaurant name to the breadcrumb navigation menu\r\n */\r\nfillBreadcrumb = (restaurant=self.restaurant) => {\r\n  const breadcrumb = document.getElementById('breadcrumb');\r\n  const li = document.createElement('li');\r\n  li.innerHTML = restaurant.name;\r\n  breadcrumb.appendChild(li);\r\n}\r\n\r\n/**\r\n * Get a parameter by name from page URL.\r\n */\r\ngetParameterByName = (name, url) => {\r\n  if (!url)\r\n    url = window.location.href;\r\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\r\n  const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),\r\n    results = regex.exec(url);\r\n  if (!results)\r\n    return null;\r\n  if (!results[2])\r\n    return '';\r\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\r\n }\r\n\r\n /**\r\n  * Fetch and Fill restaurant reviews from server\r\n  */\r\n fillRestaurantReviews = (id) => {\r\n  \r\n }\r\n\r\n/**\r\n * ADd review to the restaurant by the visitor\r\n */\r\n addReview = () => {\r\n  let id = self.id;\r\n  let author = document.getElementById('reviewAuthor');\r\n  let comment = document.getElementById('comment');\r\n  let rating = 0;\r\n  for(let i = 1; i <= 5; i++) {\r\n    let rationRadio = document.getElementById('star'+i);\r\n    if(rationRadio && rationRadio.checked) {\r\n      rating = i;\r\n    }\r\n  }\r\n  let errors = document.getElementById('errors');\r\n  let returnErrors = false;\r\n  if(!author || !author.value) {\r\n    const li = document.createElement('li');\r\n    li.innerHTML = 'Fill your name';\r\n    errors.appendChild(li);\r\n    returnErrors = true;\r\n  }  \r\n  if(!comment || !comment.value) {\r\n    const li = document.createElement('li');\r\n    li.innerHTML = 'Fill your comment';\r\n    errors.appendChild(li);\r\n    returnErrors = true;\r\n  }\r\n  if(!rating) {\r\n    const li = document.createElement('li');\r\n    li.innerHTML = 'Fill your rating';\r\n    errors.appendChild(li);\r\n    returnErrors = true;\r\n  }\r\n  if(returnErrors) {\r\n    let errorH = document.createElement('h4');\r\n    errorH.innerHTML = 'Errors in the form:';\r\n    errorH.id = 'errorHead';\r\n    let errorSection = document.getElementById('errorSection');\r\n    errorSection.appendChild(errorH);\r\n    return;\r\n  }\r\n  let errorHead = document.getElementById('errorHead');\r\n  if(errorHead) {\r\n    errorHead.parentNode.removeChild(errorHead);\r\n  }\r\n  let review = {restaurant_id: id, name: author.value, comments: comment.value, rating: rating, };\r\n  console.log(review);\r\n\r\n  DBHelper.addReviewToServer(review);\r\n  addReviewToHtml(review);\r\n\r\n  document.getElementById('add-review-form').reset();\r\n}\r\n\r\n/**\r\n * adding review wchich was proceed for errors and to backend\r\n */\r\naddReviewToHtml = (review) => {\r\n  if(!review) return;  \r\n  let noREviews = document.getElementById('noReviews');\r\n  if (noREviews) {\r\n    noREviews.parentNode.removeChild(noREviews);\r\n  }\r\n  review.createdAt = new Date();\r\n  let reviewList = document.getElementById('reviews-list');\r\n  reviewList.appendChild(createReviewHTML(review));\r\n}","//name of the database name\r\nconst dbName = 'restaurants';\r\n//name of the store name with restaurants\r\nconst storeName = 'restaurants';\r\n//name of the store name with reviews\r\nconst reviewsStoreName = 'reviews';\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL_BASE() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with data\r\n    return `http://127.0.0.1:${port}/`;\r\n  }\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with restaurant data\r\n    return `http://127.0.0.1:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Promise for indexdb db.\r\n   */\r\n  static get dbPromise() {    \r\n    //if there is no service worker available, just return\r\n    if(!navigator.serviceWorker) return Promise.resolve();\r\n    //opening db\r\n    return idb.open(dbName, 1, (db) => {\r\n      db.createObjectStore(storeName, {keyPath:'id'});\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    DBHelper.dbPromise.then(db => {\r\n      //there is no db, so first fetching of data\r\n      if(!db) {\r\n        //fetch data from server\r\n        DBHelper.xhrForRestaurant(callback);\r\n      } else {\r\n        //db exists, just get data from there\r\n        const tx = db.transaction(dbName);\r\n        const store = tx.objectStore(storeName);\r\n        store.getAll().then(restaurants => {\r\n          if(!restaurants || restaurants.length === 0) {\r\n            //no restaurants available?\r\n            DBHelper.xhrForRestaurant(callback);\r\n          } else {\r\n            //we have restaurants, yay, send them through\r\n            callback(null, restaurants)\r\n          }\r\n        });\r\n      }\r\n    });    \r\n  }\r\n\r\n  /**\r\n   * Fetch data throught xmlhttprequest\r\n   */\r\n  static xhrForRestaurant(callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.API_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const restaurantsFromJson = JSON.parse(xhr.responseText);\r\n        //save restaurants to db\r\n        DBHelper.storeRestaurantsDB(restaurantsFromJson);\r\n        callback(null, restaurantsFromJson);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }              \r\n    };\r\n    xhr.send();\r\n  }\r\n\r\n  /**\r\n   * Store all fetched restaurants in indexDB.\r\n   */\r\n  static storeRestaurantsDB(restaurants) {\r\n    DBHelper.dbPromise.then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction(dbName, \"readwrite\");\r\n      const store = tx.objectStore(storeName);\r\n      restaurants.forEach(restaurant => {\r\n        store.put(restaurant);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    if(!restaurant || restaurant.photograph === undefined) return null;\r\n    return (`/img/${restaurant.photograph}.webp`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n  static imageAltText(restaurant) {\r\n    return restaurant.name + ' restaurant in ' + restaurant.neighborhood + ' offers ' + restaurant.cuisine_type + ' cuisine type';\r\n  }\r\n\r\n  /**\r\n   * Update the favorite status of the restaurant. Based on id of restaurant and tru/false value of favorite.\r\n   */\r\n  static updateFavStatus(id, isFav) {\r\n    fetch(DBHelper.API_URL+'/'+id+'/'+'?is_favorite='+isFav,{method:'PUT'})\r\n    .then(() => {\r\n      DBHelper.dbPromise.then(db => {        \r\n        const tx = db.transaction(dbName, 'readwrite');\r\n        const store = tx.objectStore(storeName);\r\n        store.get(id).then(restaurant => {\r\n          restaurant.is_favorite = isFav;\r\n          store.put(restaurant);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews to the restaurant\r\n   */\r\n  static fetchReviewsRestaurantId(id) {\r\n    return fetch(DBHelper.API_URL_BASE+'reviews/?restaurant_id='+id)\r\n    .then((response) => {\r\n      response.json();\r\n    })\r\n    .then((reviews) => {\r\n      DBHelper.dbPromise.then(db => {\r\n        const tx = db.transaction(dbName, 'readwrite');\r\n        const store = tx.objectStore(reviewsStoreName);\r\n        if(Array.isArray(reviews)) {\r\n          reviews.forEach((review) => {\r\n            store.put(review);\r\n          });\r\n        } else {\r\n          store.put(reviews);\r\n        }\r\n      });\r\n      return Promise.resolve(reviews);\r\n    }).catch((error) => {\r\n      return DBHelper.dbPromise.then(db => {        \r\n        const tx = db.transaction(dbName, 'readwrite');\r\n        const store = tx.objectStore(reviewsStoreName);\r\n        const indexId = store.index(dbName);\r\n        return indexId.getAll(id);\r\n      }).then((storedREviews) => {\r\n        return Promise.resolve(storedREviews);\r\n      })\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reporting review to server and db\r\n   */\r\n  static addReviewToServer(review) {\r\n    if(navigator.onLine) {\r\n      DBHelper.onlineAddReview(review);\r\n    } else {\r\n      DBHelper.offlineAddReview(review);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processing review, when the user is offline\r\n   */\r\n  static offlineAddReview(review) {\r\n    const offline_review_key = 'offline_review';\r\n    localStorage.setItem(offline_review_key, JSON.stringify(review));\r\n    window.addEventListener('online', (event) => {\r\n      let offline_review = JSON.parse(localStorage.getItem(offline_review_key));\r\n      if(!offline_review) {\r\n        DBHelper.addReviewToServer(offline_review);\r\n        localStorage.removeItem(offline_review_key);\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Processing review, when the user is offline\r\n   */\r\n  static onlineAddReview(review) {\r\n    fetch(DBHelper.API_URL_BASE + 'reviews', \r\n    {\r\n      method:'POST', \r\n      headers: new Headers({'Content-Type': 'application/json'}), \r\n      body: JSON.stringify(review)\r\n    }).then((response) => {\r\n      return response;\r\n    }).catch((error) => {\r\n      console.log('error in posting online review');\r\n    });\r\n  }\r\n}"]}