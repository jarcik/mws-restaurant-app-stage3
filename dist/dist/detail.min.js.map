{"version":3,"sources":["restaurant_info.js","dbhelper.js"],"names":["restaurant","map","id","window","initMap","fetchRestaurantFromURL","error","console","self","google","maps","Map","document","getElementById","zoom","center","latlng","scrollwheel","fillBreadcrumb","DBHelper","mapMarkerForRestaurant","addEventListener","event","callback","getParameterByName","fetchRestaurantById","fillRestaurantHTML","innerHTML","name","address","image","className","src","imageUrlForRestaurant","alt","imageAltText","cuisine_type","fillRestaurantReviews","operating_hours","fillRestaurantHoursHTML","fillReviewsHTML","operatingHours","hours","key","row","createElement","day","appendChild","time","fetchReviewsRestaurantId","then","reviews","container","title","noReviews","ul","forEach","review","createReviewHTML","catch","log","newReview","li","dateElement","date","Date","updatedAt","getDay","getMonth","getFullYear","rating","comments","navigator","onLine","classList","add","breadcrumb","url","location","href","replace","results","RegExp","exec","decodeURIComponent","addReview","author","comment","i","rationRadio","checked","errors","returnErrors","value","errorH","errorHead","parentNode","removeChild","restaurant_id","parseInt","addReviewToServer","addReviewToIDB","addReviewToHtml","reset","noREviews","createdAt","getTime","dbName","storeName","reviewsStoreName","API_URL_BASE","API_URL","dbPromise","serviceWorker","idb","open","db","createObjectStore","keyPath","autoIncrement","createIndex","Promise","resolve","[object Object]","transaction","objectStore","getAll","restaurants","length","xhrForRestaurant","xhr","XMLHttpRequest","onload","status","restaurantsFromJson","JSON","parse","responseText","storeRestaurantsDB","send","store","put","fetchRestaurants","find","r","cuisine","filter","neighborhood","neighborhoods","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","undefined","photograph","Marker","position","urlForRestaurant","animation","Animation","DROP","isFav","fetch","method","get","is_favorite","response","json","data","Array","isArray","index","storedREviews","onlineAddReview","offlineAddReview","localStorage","setItem","stringify","offline_review","getItem","removeItem","offlineItems","getElementsByClassName","remove","headers","Headers","Content-Type","body"],"mappings":"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","file":"../detail.min.js","sourcesContent":["let restaurant;\r\nvar map;\r\nlet id;\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n */\r\nwindow.initMap = () => {\r\n  fetchRestaurantFromURL((error, restaurant) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      self.map = new google.maps.Map(document.getElementById('map'), {\r\n        zoom: 16,\r\n        center: restaurant.latlng,\r\n        scrollwheel: false\r\n      });\r\n      fillBreadcrumb();\r\n      DBHelper.mapMarkerForRestaurant(self.restaurant, self.map);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n  fetchRestaurantFromURL((error, restaurant) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      fillBreadcrumb();\r\n    }\r\n  });\r\n});\r\n\r\n/**\r\n * Get current restaurant from page URL.\r\n */\r\nfetchRestaurantFromURL = (callback) => {\r\n  if (self.restaurant) { // restaurant already fetched!\r\n    callback(null, self.restaurant)\r\n    return;\r\n  }\r\n  const id = getParameterByName('id');\r\n  if (!id) { // no id found in URL\r\n    error = 'No restaurant id in URL'\r\n    callback(error, null);\r\n  } else {\r\n    DBHelper.fetchRestaurantById(id, (error, restaurant) => {\r\n      self.restaurant = restaurant;\r\n      self.id = id;\r\n      if (!restaurant) {\r\n        console.error(error);\r\n        return;\r\n      }\r\n      fillRestaurantHTML();\r\n      callback(null, restaurant)\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Create restaurant HTML and add it to the webpage\r\n */\r\nfillRestaurantHTML = (restaurant = self.restaurant) => {\r\n  const name = document.getElementById('restaurant-name');\r\n  name.innerHTML = restaurant.name;\r\n\r\n  const address = document.getElementById('restaurant-address');\r\n  address.innerHTML = restaurant.address;\r\n\r\n  const image = document.getElementById('restaurant-img');\r\n  image.className = 'restaurant-img'\r\n  image.src = DBHelper.imageUrlForRestaurant(restaurant);\r\n  image.alt = DBHelper.imageAltText(restaurant);\r\n\r\n  const cuisine = document.getElementById('restaurant-cuisine');\r\n  cuisine.innerHTML = restaurant.cuisine_type;\r\n  //fill reviews\r\n  fillRestaurantReviews(restaurant.id);\r\n  // fill operating hours\r\n  if (restaurant.operating_hours) {\r\n    fillRestaurantHoursHTML();\r\n  }\r\n  // fill reviews\r\n  fillReviewsHTML();\r\n}\r\n\r\n/**\r\n * Create restaurant operating hours HTML table and add it to the webpage.\r\n */\r\nfillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {\r\n  const hours = document.getElementById('restaurant-hours');\r\n  for (let key in operatingHours) {\r\n    const row = document.createElement('tr');\r\n\r\n    const day = document.createElement('td');\r\n    day.innerHTML = key;\r\n    row.appendChild(day);\r\n\r\n    const time = document.createElement('td');\r\n    time.innerHTML = operatingHours[key];\r\n    row.appendChild(time);\r\n\r\n    hours.appendChild(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Create all reviews HTML and add them to the webpage.\r\n */\r\nfillReviewsHTML = () => {\r\n  DBHelper.fetchReviewsRestaurantId(self.restaurant.id)\r\n  .then((reviews) => {\r\n    const container = document.getElementById('reviews-container');\r\n    const title = document.createElement('h3');\r\n    title.innerHTML = 'Reviews';\r\n    container.appendChild(title);\r\n  \r\n    if (!reviews) {\r\n      const noReviews = document.createElement('p');\r\n      noReviews.innerHTML = 'No reviews yet!';\r\n      noReviews.id = 'noReviews';\r\n      container.appendChild(noReviews);\r\n      return;\r\n    }\r\n    const ul = document.getElementById('reviews-list');\r\n    reviews.forEach(review => {\r\n      ul.appendChild(createReviewHTML(review, false));\r\n    });\r\n    container.appendChild(ul);\r\n  })\r\n  .catch((error) => {\r\n    console.log('error in fetching reviews');\r\n  });\r\n}\r\n\r\n/**\r\n * Create review HTML and add it to the webpage.\r\n */\r\ncreateReviewHTML = (review, newReview) => {\r\n  const li = document.createElement('li');\r\n  const name = document.createElement('p');\r\n  name.innerHTML = review.name;\r\n  li.appendChild(name);\r\n\r\n  const dateElement = document.createElement('p');\r\n  var date = new Date(review.updatedAt);\r\n  dateElement.innerHTML = `${date.getDay()}.${date.getMonth()+1}.${date.getFullYear()}`;\r\n  li.appendChild(dateElement);\r\n\r\n  const rating = document.createElement('p');\r\n  rating.innerHTML = `Rating: ${review.rating}`;\r\n  li.appendChild(rating);\r\n\r\n  const comments = document.createElement('p');\r\n  comments.innerHTML = review.comments;\r\n  li.appendChild(comments);\r\n\r\n  //jedna se o nove review a uzivatel je offline, musi se zvyraznit, ze je offline review\r\n  if(newReview && !navigator.onLine) {\r\n    li.classList.add('offline');\r\n  }\r\n\r\n  return li;\r\n}\r\n\r\n/**\r\n * Add restaurant name to the breadcrumb navigation menu\r\n */\r\nfillBreadcrumb = (restaurant=self.restaurant) => {\r\n  const breadcrumb = document.getElementById('breadcrumb');\r\n  const li = document.createElement('li');\r\n  li.innerHTML = restaurant.name;\r\n  breadcrumb.appendChild(li);\r\n}\r\n\r\n/**\r\n * Get a parameter by name from page URL.\r\n */\r\ngetParameterByName = (name, url) => {\r\n  if (!url)\r\n    url = window.location.href;\r\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\r\n  const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),\r\n    results = regex.exec(url);\r\n  if (!results)\r\n    return null;\r\n  if (!results[2])\r\n    return '';\r\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\r\n }\r\n\r\n /**\r\n  * Fetch and Fill restaurant reviews from server\r\n  */\r\n fillRestaurantReviews = (id) => {\r\n  \r\n }\r\n\r\n/**\r\n * ADd review to the restaurant by the visitor\r\n */\r\n addReview = () => {\r\n  let id = self.id;\r\n  let author = document.getElementById('reviewAuthor');\r\n  let comment = document.getElementById('comment');\r\n  let rating = 0;\r\n  for(let i = 1; i <= 5; i++) {\r\n    let rationRadio = document.getElementById('star'+i);\r\n    if(rationRadio && rationRadio.checked) {\r\n      rating = i;\r\n    }\r\n  }\r\n  let errors = document.getElementById('errors');\r\n  let returnErrors = false;\r\n  if(!author || !author.value) {\r\n    const li = document.createElement('li');\r\n    li.innerHTML = 'Fill your name';\r\n    errors.appendChild(li);\r\n    returnErrors = true;\r\n  }  \r\n  if(!comment || !comment.value) {\r\n    const li = document.createElement('li');\r\n    li.innerHTML = 'Fill your comment';\r\n    errors.appendChild(li);\r\n    returnErrors = true;\r\n  }\r\n  if(!rating) {\r\n    const li = document.createElement('li');\r\n    li.innerHTML = 'Fill your rating';\r\n    errors.appendChild(li);\r\n    returnErrors = true;\r\n  }\r\n  if(returnErrors) {\r\n    let errorH = document.createElement('h4');\r\n    errorH.innerHTML = 'Errors in the form:';\r\n    errorH.id = 'errorHead';\r\n    let errorSection = document.getElementById('errorSection');\r\n    errorSection.appendChild(errorH);\r\n    return;\r\n  }\r\n  let errorHead = document.getElementById('errorHead');\r\n  if(errorHead) {\r\n    errorHead.parentNode.removeChild(errorHead);\r\n  }\r\n  let review = {restaurant_id: parseInt(id), name: author.value, comments: comment.value, rating: rating, };\r\n  console.log(review);\r\n\r\n  DBHelper.addReviewToServer(review);\r\n  DBHelper.addReviewToIDB(review);  \r\n  addReviewToHtml(review);\r\n\r\n  document.getElementById('add-review-form').reset();\r\n}\r\n\r\n/**\r\n * adding review wchich was proceed for errors and to backend\r\n */\r\naddReviewToHtml = (review) => {\r\n  if(!review) return;  \r\n  let noREviews = document.getElementById('noReviews');\r\n  if (noREviews) {\r\n    noREviews.parentNode.removeChild(noREviews);\r\n  }\r\n  review.createdAt = new Date().getTime();\r\n  review.updatedAt = new Date().getTime();\r\n  let reviewList = document.getElementById('reviews-list');\r\n  reviewList.appendChild(createReviewHTML(review, true));\r\n}","//name of the database name\r\nconst dbName = 'restaurants';\r\n//name of the store name with restaurants\r\nconst storeName = 'restaurants';\r\n//name of the store name with reviews\r\nconst reviewsStoreName = 'reviews';\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL_BASE() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with data\r\n    return `http://127.0.0.1:${port}/`;\r\n  }\r\n\r\n  /**\r\n   * API URL\r\n   */\r\n  static get API_URL() {\r\n    const port = 1337 // Change this to YOUR server port\r\n    //url to server with restaurant data\r\n    return `http://127.0.0.1:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Promise for indexdb db.\r\n   */\r\n  static get dbPromise() {    \r\n    //if there is no service worker available, just return\r\n    if(!navigator.serviceWorker) return Promise.resolve();\r\n    //opening db\r\n    return idb.open(dbName, 1, (db) => {\r\n      db.createObjectStore(storeName, {keyPath:'id'});\r\n      var reviewsStore = db.createObjectStore(reviewsStoreName, {keyPath:'id', autoIncrement: true});\r\n      reviewsStore.createIndex('restaurant_id', 'restaurant_id');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    DBHelper.dbPromise.then(db => {\r\n      //there is no db, so first fetching of data\r\n      if(!db) {\r\n        //fetch data from server\r\n        DBHelper.xhrForRestaurant(callback);\r\n      } else {\r\n        //db exists, just get data from there\r\n        const tx = db.transaction(dbName);\r\n        const store = tx.objectStore(storeName);\r\n        store.getAll().then(restaurants => {\r\n          if(!restaurants || restaurants.length === 0) {\r\n            //no restaurants available?\r\n            DBHelper.xhrForRestaurant(callback);\r\n          } else {\r\n            //we have restaurants, yay, send them through\r\n            callback(null, restaurants)\r\n          }\r\n        });\r\n      }\r\n    });    \r\n  }\r\n\r\n  /**\r\n   * Fetch data throught xmlhttprequest\r\n   */\r\n  static xhrForRestaurant(callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.API_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const restaurantsFromJson = JSON.parse(xhr.responseText);\r\n        //save restaurants to db\r\n        DBHelper.storeRestaurantsDB(restaurantsFromJson);\r\n        callback(null, restaurantsFromJson);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }              \r\n    };\r\n    xhr.send();\r\n  }\r\n\r\n  /**\r\n   * Store all fetched restaurants in indexDB.\r\n   */\r\n  static storeRestaurantsDB(restaurants) {\r\n    DBHelper.dbPromise.then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction(dbName, \"readwrite\");\r\n      const store = tx.objectStore(storeName);\r\n      restaurants.forEach(restaurant => {\r\n        store.put(restaurant);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    if(!restaurant || restaurant.photograph === undefined) return null;\r\n    return (`/img/${restaurant.photograph}.webp`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n  static imageAltText(restaurant) {\r\n    return restaurant.name + ' restaurant in ' + restaurant.neighborhood + ' offers ' + restaurant.cuisine_type + ' cuisine type';\r\n  }\r\n\r\n  /**\r\n   * Update the favorite status of the restaurant. Based on id of restaurant and tru/false value of favorite.\r\n   */\r\n  static updateFavStatus(id, isFav) {\r\n    fetch(DBHelper.API_URL+'/'+id+'/'+'?is_favorite='+isFav,{method:'PUT'})\r\n    .then(() => {\r\n      DBHelper.dbPromise.then(db => {        \r\n        const tx = db.transaction(dbName, 'readwrite');\r\n        const store = tx.objectStore(storeName);\r\n        store.get(id).then(restaurant => {\r\n          restaurant.is_favorite = isFav;\r\n          store.put(restaurant);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews to the restaurant\r\n   */\r\n  static fetchReviewsRestaurantId(id) {\r\n    // let xhr = new XMLHttpRequest();\r\n    // xhr.open('GET', DBHelper.API_URL_BASE+'reviews/?restaurant_id='+id);\r\n    // xhr.onload = () => {\r\n    //   if (xhr.status === 200) { // Got a success response from server!\r\n    //     const reviews = JSON.parse(xhr.responseText);\r\n    //     return DBHelper.dbPromise.then(db => {\r\n    //       const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n    //       const store = tx.objectStore(reviewsStoreName);\r\n    //       if(Array.isArray(reviews)) {\r\n    //         reviews.forEach((review) => {\r\n    //           store.put(review);\r\n    //         });\r\n    //       } else {\r\n    //         store.put(reviews);\r\n    //       }\r\n    //     });\r\n    //     return Promise.resolve(reviews);\r\n    //   } else { // Oops!. Got an error from server.\r\n    //     const error = (`Request failed. Returned status of ${xhr.status}`);\r\n    //     return DBHelper.dbPromise.then(db => {        \r\n    //       const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n    //       const store = tx.objectStore(reviewsStoreName);\r\n    //       const indexId = store.index(dbName);\r\n    //       return indexId.getAll(id);\r\n    //     }).then((storedREviews) => {\r\n    //       return Promise.resolve(storedREviews);\r\n    //     })\r\n    //   }              \r\n    // };\r\n    // xhr.send();\r\n    if(navigator.onLine) {\r\n        return fetch(DBHelper.API_URL_BASE+'reviews/?restaurant_id='+id)\r\n      .then((response) => {\r\n        return response.json().then((data) => {\r\n          return DBHelper.dbPromise.then(db => {\r\n            const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n            const store = tx.objectStore(reviewsStoreName);\r\n            if(Array.isArray(data)) {\r\n              data.forEach((review) => {\r\n                store.put(review);\r\n              });\r\n            } else {\r\n              store.put(data);\r\n            }\r\n            return Promise.resolve(data);\r\n          });\r\n        });      \r\n      }).catch((error) => {\r\n        return DBHelper.dbPromise.then(db => {        \r\n          const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n          const store = tx.objectStore(reviewsStoreName);\r\n          const indexId = store.index('restaurant_id');\r\n          return indexId.getAll(id);\r\n        }).then((storedREviews) => {\r\n          return Promise.resolve(storedREviews);\r\n        })\r\n      });\r\n    } else {\r\n      return DBHelper.dbPromise.then(db => {        \r\n        const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n        const store = tx.objectStore(reviewsStoreName);\r\n        const indexId = store.index('restaurant_id');\r\n        return indexId.getAll(id);\r\n      }).then((storedREviews) => {\r\n        return Promise.resolve(storedREviews);\r\n      })\r\n    }    \r\n  }\r\n\r\n  /**\r\n   * Reporting review to server and db\r\n   */\r\n  static addReviewToServer(review) {\r\n    if(navigator.onLine) {\r\n      DBHelper.onlineAddReview(review);\r\n    } else {\r\n      DBHelper.offlineAddReview(review);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reporting review to idb\r\n   */\r\n  static addReviewToIDB(review) {\r\n    //put to indexdb\r\n    DBHelper.dbPromise.then(db => {\r\n      const tx = db.transaction(reviewsStoreName, 'readwrite');\r\n      const store = tx.objectStore(reviewsStoreName);\r\n      store.put(review);      \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Processing review, when the user is offline\r\n   */\r\n  static offlineAddReview(review) {\r\n    const offline_review_key = 'offline_review';\r\n    localStorage.setItem(offline_review_key, JSON.stringify(review));\r\n    window.addEventListener('online', (event) => {\r\n      let offline_review = JSON.parse(localStorage.getItem(offline_review_key));\r\n      if(offline_review) {\r\n        DBHelper.addReviewToServer(offline_review);\r\n        localStorage.removeItem(offline_review_key);\r\n        var offlineItems = document.getElementById('reviews-list').getElementsByClassName('offline');\r\n        if(offlineItems) {\r\n          for (var i = 0; i < offlineItems.length; i++) {\r\n            offlineItems[i].classList.remove('offline');\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Processing review, when the user is offline\r\n   */\r\n  static onlineAddReview(review) {\r\n    fetch(DBHelper.API_URL_BASE + 'reviews', \r\n    {\r\n      method:'POST', \r\n      headers: new Headers({'Content-Type': 'application/json'}), \r\n      body: JSON.stringify(review)\r\n    }).then((response) => {\r\n      return response;\r\n    }).catch((error) => {\r\n      console.log('error in posting online review');\r\n      console.log(error);\r\n    });\r\n  }\r\n\r\n}"]}